# 결제 팝업창 타이머 연동 문제 해결

작성일: 2025-11-06

---

## 1. 3C (Context, Core, Concern)

### Context (배경)

- **서비스**: Stay One Korea - 숙박 예약 및 결제 시스템
- **기술 스택**:
  - Frontend: Next.js 14 (App Router), React, TypeScript
  - 결제 시스템: PortOne v2 Browser SDK
  - PG사: Eximbay v2 (카드 결제)
- **현재 상태**:
  - 예약 프로세스에서 사용자에게 10분의 예약 유효 시간 제공
  - 타이머 만료 시 서버에서 예약 데이터 자동 삭제
  - 결제는 PortOne SDK를 통해 팝업창으로 진행

### Core (핵심 문제)

예약 타이머가 만료되어 페이지가 홈으로 이동(`window.location.href = '/'`)되어도, PortOne SDK가 열어둔 결제 팝업창은 계속 열려있어 사용자가 이미 삭제된 예약에 대해 결제를 계속 진행할 수 있는 문제 발생.

### Concern (고려사항)

1. **사용자 경험**: 타이머 만료 시 명확한 피드백과 함께 결제 프로세스 종료 필요
2. **데이터 정합성**: 서버에서 삭제된 예약에 대한 결제 방지
3. **PG사 제약**: Eximbay v2는 특정 결제창 타입(IFRAME)을 지원하지 않음
4. **브라우저 호환성**: 다양한 브라우저에서 팝업 제어가 가능해야 함
5. **SDK 제약**: PortOne SDK가 내부적으로 팝업을 관리하므로 직접 접근 불가

---

## 2. 4P (Problem, Proposal, Plan, Profile)

### 2.1. Problem (문제 정의)

#### 발생한 이슈

```
현상: 예약 타이머 만료 시 페이지는 홈으로 이동하지만,
      결제 팝업창은 계속 열려있어 사용자가 결제를 진행할 수 있음

영향: - 이미 삭제된 예약에 대한 결제 시도 가능
      - 사용자 혼란 및 결제 실패 발생
      - 잘못된 결제 데이터 생성 가능
```

#### 재현 조건

1. 결제 페이지 진입 (예약 타이머 시작)
2. "Book Now with PayPal" 버튼 클릭 → PortOne 결제 팝업 열림
3. 결제 진행 중 타이머 만료 (10분 경과)
4. 메인 페이지는 홈으로 이동하지만 팝업은 여전히 열려있음
5. 사용자가 팝업에서 결제를 완료할 수 있음 (예약은 이미 삭제됨)

#### 기술적 원인

- `window.location.href = '/'` 실행 시 현재 페이지만 이동
- PortOne SDK의 `requestPayment()`가 반환하는 팝업 창 참조에 접근 불가
- SDK가 내부적으로 `window.open()`을 호출하지만 참조를 반환하지 않음

---

### 2.2. Proposal (해결책 제안)

#### 최종 채택 해결책: Window.open 가로채기 (Monkey Patching)

**핵심 아이디어**:
PortOne SDK가 결제 팝업을 열기 전에 `window.open`을 임시로 가로채서(override) 팝업 참조를 획득한 후, 타이머 만료 시 해당 참조를 통해 팝업을 강제로 닫는다.

**동작 원리**:

```typescript
// 1. 원본 window.open 저장
const originalOpen = window.open

// 2. window.open을 가로채서 팝업 참조 획득
window.open = function(...args) {
  const popup = originalOpen.apply(this, args as any)
  if (popup) {
    setPaymentPopup(popup)  // 팝업 참조 저장
  }
  return popup
}

// 3. SDK 호출 (내부적으로 가로챈 window.open 사용)
await PortOne.requestPayment({...})

// 4. 원본 복원
window.open = originalOpen

// 5. 타이머 만료 시 팝업 강제 종료
if (paymentPopup && !paymentPopup.closed) {
  paymentPopup.close()
}
```

**왜 이 해결책이 최선인가?**

- ✅ PG사 제약 없음: 팝업 방식 그대로 사용 (Eximbay 호환)
- ✅ SDK 제약 극복: SDK 수정 없이 팝업 참조 획득
- ✅ 확실한 제어: 타이머 만료 시 팝업 강제 종료 보장
- ✅ 브라우저 호환: 표준 `window.open` API 사용

---

### 2.3. Plan (실행 계획)

#### Step 1: State 추가

```typescript
// 팝업 참조를 저장할 state 추가
const [paymentPopup, setPaymentPopup] = useState<Window | null>(null);
```

#### Step 2: 결제 함수 수정

```typescript
const handlePayPalPayment = async () => {
  // window.open 원본 저장 (try-catch 바깥에서)
  const originalOpen = window.open;

  try {
    // window.open 가로채기
    window.open = function (...args) {
      const popup = originalOpen.apply(this, args as any);
      if (popup) {
        setPaymentPopup(popup);
      }
      return popup;
    };

    // PortOne SDK 호출
    const response = await PortOne.requestPayment({
      // ... 기존 설정
      windowType: {
        mobile: "REDIRECTION", // 팝업 방식 유지
      },
      popup: {
        center: true,
      },
    });

    // window.open 복원
    window.open = originalOpen;

    // 팝업 정리
    if (paymentPopup && !paymentPopup.closed) {
      paymentPopup.close();
    }
    setPaymentPopup(null);
  } catch (error) {
    // 에러 시에도 복원 및 정리
    window.open = originalOpen;
    if (paymentPopup && !paymentPopup.closed) {
      paymentPopup.close();
    }
    setPaymentPopup(null);
  }
};
```

#### Step 3: 타이머 로직 수정

```typescript
useEffect(() => {
  if (timeRemaining === null || timeRemaining <= 0 || !endToReserveTime) return;

  const timer = setInterval(() => {
    // ... 타이머 계산 로직

    if (newTimeRemaining <= 0) {
      clearInterval(timer);

      // 결제 팝업 강제 종료
      if (paymentPopup && !paymentPopup.closed) {
        try {
          paymentPopup.close();
        } catch (error) {
          console.error("Failed to close payment popup:", error);
        }
      }

      alert(
        messages?.reservation?.timeExpired || "예약 가능 시간이 만료되었습니다."
      );
      window.location.href = "/";
      return;
    }

    setTimeRemaining(newTimeRemaining);
  }, 1000);

  return () => clearInterval(timer);
}, [timeRemaining, endToReserveTime, paymentPopup, messages]);
```

#### Step 4: Dependency 업데이트

```typescript
// useEffect의 의존성 배열에 paymentPopup 추가
}, [timeRemaining, endToReserveTime, params.reservationId, router, messages, paymentPopup])
```

---

### 2.4. Profile (영향 분석)

#### 긍정적 영향

1. **데이터 정합성 보장** ✅
   - 타이머 만료 시 팝업이 확실히 닫혀 삭제된 예약에 대한 결제 차단
2. **사용자 경험 개선** ✅

   - 명확한 프로세스 종료로 사용자 혼란 방지
   - 타이머 만료 시 일관된 동작 제공

3. **PG사 호환성 유지** ✅

   - Eximbay의 팝업 방식 그대로 사용
   - 추가 PG사 연동 시에도 적용 가능

4. **안정성 향상** ✅
   - 에러 발생 시에도 원본 `window.open` 복원
   - 팝업 정리 로직으로 메모리 누수 방지

#### 잠재적 위험 및 대응

1. **Monkey Patching의 부작용** ⚠️

   - 문제: 다른 라이브러리가 `window.open` 사용 시 충돌 가능
   - 대응: 결제 프로세스 시작 직전에만 임시 적용, 완료 후 즉시 복원

2. **브라우저 팝업 차단** ⚠️

   - 문제: 일부 브라우저가 팝업 차단 정책으로 close() 실패 가능
   - 대응: try-catch로 감싸고 에러 발생 시에도 페이지 이동 진행

3. **동시성 이슈** ⚠️
   - 문제: 사용자가 여러 번 결제 버튼 클릭 시 여러 팝업 발생 가능
   - 대응: 결제 진행 중 버튼 비활성화 로직 추가 필요 (향후 개선)

#### 성능 영향

- **미미함**: `window.open` override는 함수 참조 교체로 성능 오버헤드 거의 없음
- **메모리**: 팝업 참조 하나만 추가로 저장 (4-8 bytes)

---

## 부록: 채택되지 않은 대안 상세 분석

### 대안 1: IFRAME 방식 사용

#### 개념

PortOne SDK의 `windowType`을 `IFRAME`으로 설정하여 페이지 내부에 iframe으로 결제창을 표시. 페이지 이동 시 iframe이 DOM에서 자동으로 제거되므로 별도 제어 불필요.

#### 구현 예시

```typescript
const response = await PortOne.requestPayment({
  // ... 기타 설정
  windowType: {
    pc: "IFRAME", // 데스크톱: iframe
    mobile: "REDIRECTION",
  },
  // popup 옵션 제거
});
```

#### 장점

- 별도 제어 로직 불필요 (페이지 이동 시 자동 정리)
- 팝업 차단기 영향 없음
- 구현이 가장 단순함

#### 단점 (채택하지 않은 이유)

**결정적 이유**: Eximbay v2 PG사가 IFRAME 방식을 지원하지 않음

```
에러 메시지:
"결제 창 호출에 실패하였습니다.
PC 환경에서 지원하지 않는 PG사 창 유형(IFRAME)입니다."
```

- PG사별로 지원하는 windowType이 다름
- 다른 PG사 추가 시에도 호환성 문제 발생 가능
- 결제창 디자인 제어 제한

---

### 대안 2: loadPaymentUI 사용

#### 개념

PortOne SDK v2의 `loadPaymentUI()` 함수를 사용. 이 함수는 결제창 컨트롤러를 반환하여 `controller.close()`로 직접 제어 가능.

#### 구현 예시

```typescript
// State 추가
const [paymentUIController, setPaymentUIController] = useState<any>(null);

const handlePayPalPayment = async () => {
  // loadPaymentUI 사용
  const controller = await PortOne.loadPaymentUI({
    storeId: "...",
    channelKey: "...",
    // ... 기타 설정
  });

  setPaymentUIController(controller);

  // 결제 결과 대기
  const response = await controller.getResult();

  // 종료
  controller.close();
};

// 타이머에서 강제 종료
if (paymentUIController) {
  paymentUIController.close();
}
```

#### 장점

- SDK가 공식적으로 제공하는 방법
- 더 세밀한 제어 가능 (업데이트, 닫기 등)
- Monkey Patching 없이 안전한 방법

#### 단점 (채택하지 않은 이유)

1. **API 차이**: `loadPaymentUI`는 `requestPayment`와 다른 API

   - 기존 코드 대부분 수정 필요
   - 테스트 및 검증 시간 필요

2. **PG사 호환성 불확실**:

   - `loadPaymentUI`도 내부적으로 IFRAME이나 다른 방식 사용 가능
   - Eximbay와의 호환성 사전 검증 필요

3. **문서 부족**:

   - PortOne v2 문서에서 `loadPaymentUI` 상세 가이드 부족
   - 트러블슈팅 시 참고 자료 제한적

4. **개발 일정**:
   - 빠른 해결이 필요한 상황
   - 기존 코드 최소 수정으로 해결 선호

---

### 대안 3: 타이머 일시 중지 (Pause Timer)

#### 개념

결제 팝업이 열려있는 동안 타이머를 일시 중지하고, 팝업이 닫히면 다시 재개. 타이머 만료와 결제 프로세스를 동시에 진행하지 않도록 함.

#### 구현 예시

```typescript
const [isPaymentInProgress, setIsPaymentInProgress] = useState(false)

// 타이머 useEffect
useEffect(() => {
  // 결제 진행 중이면 타이머 멈춤
  if (isPaymentInProgress) return

  const timer = setInterval(() => {
    // 타이머 로직
  }, 1000)

  return () => clearInterval(timer)
}, [timeRemaining, isPaymentInProgress])

const handlePayPalPayment = async () => {
  setIsPaymentInProgress(true)  // 타이머 일시 중지

  const response = await PortOne.requestPayment({...})

  setIsPaymentInProgress(false)  // 타이머 재개
}
```

#### 장점

- 사용자가 충분한 시간을 갖고 결제 진행 가능
- 구현이 비교적 단순
- SDK나 PG사 제약 없음

#### 단점 (채택하지 않은 이유)

**결정적 이유**: 비즈니스 요구사항과 충돌

1. **예약 삭제 정책 위반**:

   - 서버는 정해진 시간에 예약을 삭제함
   - 클라이언트에서 타이머만 멈춰도 서버의 예약은 삭제됨
   - 결제 완료 시 이미 예약이 없는 상태

2. **악용 가능성**:

   - 사용자가 결제창을 열어두고 무한정 시간 늘릴 수 있음
   - 최대 시간 제한을 두어도 근본적 해결책 아님

3. **비즈니스 로직 불일치**:
   - "타이머 내에 결제를 완료해야 한다"는 정책과 모순
   - 재고 관리, 가격 변동 등의 이유로 시간 제한이 존재

---

## 결론

**window.open 가로채기** 방식이 현재 상황에서 최적의 해결책으로 판단됨:

1. ✅ PG사 제약 없음 (Eximbay 호환)
2. ✅ 비즈니스 로직 유지 (타이머 정책 준수)
3. ✅ 최소한의 코드 수정
4. ✅ 확실한 동작 보장
5. ✅ 빠른 개발 및 배포 가능

다만, Monkey Patching의 부작용을 고려하여 향후 PortOne SDK 업데이트나 공식 API 제공 시 마이그레이션을 고려해야 함.

---

## 참고 자료

- PortOne Browser SDK v2: https://developers.portone.io/
- MDN window.open: https://developer.mozilla.org/en-US/docs/Web/API/Window/open
